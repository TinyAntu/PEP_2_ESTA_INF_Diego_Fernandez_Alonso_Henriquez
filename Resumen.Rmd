---
title: "Codigo util"
output: html_document
date: "2024-12-26"
---

# Alternativas para analisis de datos problematicos

## Alternativa robusta a las medias

Para cuando contamos con valores extremos atipicos podemos utilizar la media Windorizada la caul se puede calcular con winmean  del paquete WRS2:

```{r}
library(WRS2)
#Ignora el 20% de los datos en cada extremo
x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100)
winmean(x, tr = 0.2)
```
## Prueba de Yuen para 2 muestras independientes

Alternativa a T Student para muestras independientes es utilizada cuando las varianzas de ambas muestras son muy diferentes o los tamaños de las muestras son muy dispares. No se recomienda esto si es que el nivel de truncamiento esta cerca de 0.5.

H0: Medias iguales

Ha: Medias diferentes

La funcion es yuenbt del paquete WRS2 (formula es : Variable dependiente ~ Variable independiente):

```{r}
library(WRS2)
library(ggpubr)

#Ejemplo

a <- c(25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0
       ,26.1,26.2,26.3,26.4,26.5,26.6,26.7,26.8,26.9,27.0,
       27.1,27.2,27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.4,
       28.5,29.0,29.8,30.2,31.8,31.9,33.3,33.7)

b <- c(24.1,24.2,24.3,24.4,24.5,24.6,24.7,24.8,24.9,25.0,
       25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0,26.1,
       26.2,26.3,27.1,27.2,
       27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.1,28.2,28.3,30.0,30.1,30.2,30.3)

tiempo <- c(a,b)
algoritmo  <- c(rep("A",length(a)),rep("B",length(b)))
datos <- data.frame(tiempo,algoritmo)

#Comprobar normalidad
#Antes del truncamientio
g <- ggqqplot(datos, x = "tiempo", facet.by = "algoritmo",
             palette = c("blue", "red"), color ="algoritmo")

print(g)

#Poda
gamma <- 0.2

n_a <- length(a)
n_b <- length(b)

poda_a <- n_a * gamma
poda_b <- n_b * gamma

a_truncada <- a[poda_a:(n_a - poda_a)]
b_truncada <- b[poda_b:(n_b - poda_b)]

tiempo <- c(a_truncada,b_truncada)
algoritmo <- c(rep("A",length(a_truncada)),rep("B",length(b_truncada)))
datos_truncados <- data.frame(tiempo,algoritmo)

#Despues del truncamientio 
g <- ggqqplot(datos_truncados, x = "tiempo", facet.by = "algoritmo",
              palette = c("blue", "red"), color = "algoritmo")

print(g)

#Prueba de Yuen
yuen(tiempo ~ algoritmo, data = datos_truncados, tr = gamma)


```
Otra opcion es pb2gen que utiliza boostraping para aplicar la prueba de yuen usando otras medidas robustas de tendencia central.

```{r}
library(WRS2)


#Ejemplo

a <- c(25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0
       ,26.1,26.2,26.3,26.4,26.5,26.6,26.7,26.8,26.9,27.0,
       27.1,27.2,27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.4,
       28.5,29.0,29.8,30.2,31.8,31.9,33.3,33.7)

b <- c(24.1,24.2,24.3,24.4,24.5,24.6,24.7,24.8,24.9,25.0,
       25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0,26.1,
       26.2,26.3,27.1,27.2,
       27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.1,28.2,28.3,30.0,30.1,30.2,30.3)

tiempo <- c(a,b)
algoritmo  <- c(rep("A",length(a)),rep("B",length(b)))
datos <- data.frame(tiempo,algoritmo)

bootstrap <- 999

set.seed(135)

prueba_media <- pb2gen(tiempo ~ algoritmo, data = datos, est = "mean", nboot = bootstrap)

cat("Resultado al utilizar media como estimador \n")
print(prueba_media)

set.seed(135)

prueba_mediana <- pb2gen(tiempo ~ algoritmo, data = datos, est = "median", nboot = bootstrap)

cat("Resultado al utilizar mediana como estimador \n")
print(prueba_mediana)

```
## Prueba de Yuen para 2 muestras pareadas

```{r}
library(WRS2)


#Ejemplo

a <- c(25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0
       ,26.1,26.2,26.3,26.4,26.5,26.6,26.7,26.8,26.9,27.0,
       27.1,27.2,27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.4,
       28.5,29.0,29.8,30.2,31.8,31.9,33.3,33.7)

b <- c(24.1,24.2,24.3,24.4,24.5,24.6,24.7,24.8,24.9,25.0,
       25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0,26.1,
       26.2,26.3,27.1,27.2,27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0
       ,28.1,28.2,28.3,30.0,30.1,30.2)

#Aplicar prueba para muestras pareadas

gama <- 0.2
yuend(a, b, tr = gamma)

```
## Comparaciones de una via para multiples grupos independientes

El paquete WRS2 ofrece diferentes alternativas a ANOVA de una via para muestras independientes es util para cuando los tamaño de las muestrasn son muy diferentes o no se cumple la homocedasticidad.

Para esto se utiliza t1way que es un procedimiento como el ANOVA pero con medias truncadas y para el analisis PostHoc es con lincon, para posthoc con bootstrap en con mcppb20.

Otra opcion es med1way que realiza un ANOVA iterativo pero este no cuenta con analisis PostHoc

```{r}
library(WRS2)

#Matriz de datos

a <- c(25.1, 25.2, 25.3, 25.3, 25.4, 25.4, 25.5, 25.5, 25.6, 25.8, 25.8, 25.9, 25.9, 26.0, 26.0, 26.2, 26.2, 26.3, 26.4, 26.5, 26.5, 26.6, 26.7, 26.7, 26.9, 27.0, 27.1, 27.3, 27.8, 28.4, 28.5, 29.0, 29.8, 30.2, 31.8, 31.9, 33.3, 33.7)

b <- c(24.1, 24.4, 24.4, 24.5, 24.7, 24.8, 24.8, 25.1, 25.2, 25.2, 25.3, 25.4, 25.7, 25.7, 25.7, 26.3, 26.4, 26.5, 27.2, 27.7, 28.3, 28.4, 28.4, 28.6, 28.7, 29.6, 29.9, 30.1, 30.5)

c <- c(24.5, 24.5, 24.5, 24.5, 24.5, 24.5, 24.6, 24.6, 24.6, 24.6, 24.7, 24.7, 24.7, 24.7, 24.8, 25.0, 25.0, 25.0, 25.2, 25.2, 25.2, 25.5, 25.5, 25.7, 25.9, 26.2, 26.5, 26.5, 26.7, 27.0, 29.2, 29.9, 30.1)

tiempo <- c(a, b, c)
algoritmo <- c(rep("A", length(a)), rep("B", length(b)), rep("C", length(c)))
datos <- data.frame(tiempo, algoritmo)

# Fijar nivel de significación.
alfa <- 0.05

# Comparar los diferentes algoritmos usando medias truncadas.
cat("Comparación entre grupos usando medias truncadas\n\n")
gamma <- 0.2

set.seed(666)

medias_truncadas <- t1way(tiempo ~ algoritmo, data = datos, tr = gamma, alpha = alfa)


print(medias_truncadas)

set.seed(666)
muestras <- 999

cat("Post hoc iterativo\n\n")

post_hoc <- lincon(tiempo ~ algoritmo, data = datos, tr = gamma, alpha = alfa)

print(post_hoc)

cat("Post hoc con bootstrap\n\n")
set.seed(666)
boot <- t1waybt(tiempo ~ algoritmo, data = datos, tr = gamma, nboot = muestras, alpha = alfa)

print(boot)


set.seed(666)
post_hoc_2 <- mcppb20(tiempo ~ algoritmo, data = datos, tr = gamma, nboot = muestras, alpha = alfa)

print(post_hoc_2)

```
## Comparaciones de una via para multiples grupos correlacionados

Es util cuando los datos violan la condicion de esferecidad 

Para esto la funcion es rmanova y para el post hoc es rmmcp. Aparte para incorporar bootstraping tenemos rmanovab y el post hoc seria con pairdepb

```{r}
library(WRS2)
library(tidyverse)

# Construir data frame.
X <- c(32.0, 32.0, 32.0, 32.0, 32.1, 32.1, 32.1, 32.2,32.3, 32.3, 32.5,
       32.7, 32.7, 32.7, 33.1, 33.4, 33.9, 34.1, 34.2, 34.5, 36.0, 36.6, 
       36.7, 37.2, 38.0)

Y <- c(33.0, 33.0, 33.0, 33.0,33.3, 33.3, 33.3, 33.3, 33.5, 
       33.6, 33.7, 33.9, 33.9, 34.2, 34.2, 34.3, 34.3, 34.3, 34.4, 34.4, 
       34.5, 34.6, 36.4, 38.9, 40.2)

Z <- c(32.0, 32.2, 32.5, 32.6, 32.7, 32.7, 32.7, 33.0, 33.2, 33.4, 33.6, 
       33.6, 33.9, 34.1, 34.2, 34.4, 34.4, 34.5, 34.6, 34.7, 36.3, 36.6, 
       36.7, 38.9, 39.2)

instancia <- 1:length(X)
datos <- data.frame(instancia, X, Y, Z)

#Llevar data frame a formato largo

datos_largo <- datos %>% pivot_longer( c("X", "Y", "Z"), names_to = "algoritmo", values_to = "tiempo")

datos[["algoritmo"]] <- factor(datos[["algoritmo"]])

# Fijar nivel de significación.
alfa <- 0.05

# Aplicarl alternativa robusta a ANOVA de una via con muestras correlacionadas
gamma <- 0.2

prueba <- rmanova(y = datos[["tiempo"]], groups = datos[["algoritmo"]], blocks = datos[["instancia"]], tr = gamma)

print(prueba)

post_hoc <- rmmcp(y = datos[["tiempo"]], groups = datos[["algoritmo"]], blocks = datos[["instancia"]], tr = gamma, alpha = alfa)

print(post_hoc)
```

