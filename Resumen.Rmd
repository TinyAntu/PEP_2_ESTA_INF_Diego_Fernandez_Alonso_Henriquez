---
title: "Codigo util"
output: html_document
date: "2024-12-26"
---

# Alternativas para analisis de datos problematicos

## Alternativa robusta a las medias

Para cuando contamos con valores extremos atipicos podemos utilizar la media Windorizada la caul se puede calcular con winmean  del paquete WRS2:

```{r}
library(WRS2)
#Ignora el 20% de los datos en cada extremo
x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100)
winmean(x, tr = 0.2)
```
## Prueba de Yuen para 2 muestras independientes

Alternativa a T Student para muestras independientes es utilizada cuando las varianzas de ambas muestras son muy diferentes o los tamaÃ±os de las muestras son muy dispares. No se recomienda esto si es que el nivel de truncamiento esta cerca de 0.5.

H0: Medias iguales

Ha: Medias diferentes

La funcion es yuenbt del paquete WRS2 (formula es : Variable dependiente ~ Variable independiente):

```{r}
library(WRS2)
library(ggpubr)

#Ejemplo

a <- c(25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0
       ,26.1,26.2,26.3,26.4,26.5,26.6,26.7,26.8,26.9,27.0,
       27.1,27.2,27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.4,
       28.5,29.0,29.8,30.2,31.8,31.9,33.3,33.7)

b <- c(24.1,24.2,24.3,24.4,24.5,24.6,24.7,24.8,24.9,25.0,
       25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0,26.1,
       26.2,26.3,27.1,27.2,
       27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.1,28.2,28.3,30.0,30.1,30.2,30.3)

tiempo <- c(a,b)
algoritmo  <- c(rep("A",length(a)),rep("B",length(b)))
datos <- data.frame(tiempo,algoritmo)

#Comprobar normalidad
#Antes del truncamientio
g <- ggqqplot(datos, x = "tiempo", facet.by = "algoritmo",
             palette = c("blue", "red"), color ="algoritmo")

print(g)

#Poda
gamma <- 0.2

n_a <- length(a)
n_b <- length(b)

poda_a <- n_a * gamma
poda_b <- n_b * gamma

a_truncada <- a[poda_a:(n_a - poda_a)]
b_truncada <- b[poda_b:(n_b - poda_b)]

tiempo <- c(a_truncada,b_truncada)
algoritmo <- c(rep("A",length(a_truncada)),rep("B",length(b_truncada)))
datos_truncados <- data.frame(tiempo,algoritmo)

#Despues del truncamientio 
g <- ggqqplot(datos_truncados, x = "tiempo", facet.by = "algoritmo",
              palette = c("blue", "red"), color = "algoritmo")

print(g)

#Prueba de Yuen
yuen(tiempo ~ algoritmo, data = datos_truncados, tr = gamma)


```
Otra opcion es pb2gen que utiliza boostraping para aplicar la prueba de yuen usando otras medidas robustas de tendencia central.

```{r}
library(WRS2)


#Ejemplo

a <- c(25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0
       ,26.1,26.2,26.3,26.4,26.5,26.6,26.7,26.8,26.9,27.0,
       27.1,27.2,27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.4,
       28.5,29.0,29.8,30.2,31.8,31.9,33.3,33.7)

b <- c(24.1,24.2,24.3,24.4,24.5,24.6,24.7,24.8,24.9,25.0,
       25.1,25.2,25.3,25.4,25.5,25.6,25.7,25.8,25.9,26.0,26.1,
       26.2,26.3,27.1,27.2,
       27.3,27.4,27.5,27.6,27.7,27.8,27.9,28.0,28.1,28.2,28.3,30.0,30.1,30.2,30.3)

tiempo <- c(a,b)
algoritmo  <- c(rep("A",length(a)),rep("B",length(b)))
datos <- data.frame(tiempo,algoritmo)

bootstrap <- 999

set.seed(135)

prueba_media <- pb2gen(tiempo ~ algoritmo, data = datos, est = "mean", nboot = bootstrap)

cat("Resultado al utilizar media como estimador \n")
print(prueba_media)



```

